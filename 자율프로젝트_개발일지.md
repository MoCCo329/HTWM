### 2022/10/19/수

처음으로 CRA 없이 webpack과 babel, eslint, prettier 설정을 통해 React와 electron 개발환경을 구축했다. 구글링해서 한 것이고, 다시해도 검색없이는 못하겠지만 생각보다 어려운 작업은 없었다. 다만 몇가지 시간이 끌린 작업들이 있었다.

그중 하나는 build시 electron에 아무것도 안뜨는점이 문제였는데, webpack의 HtmlWebpackPlugin이 build시 index.html에 주입해 주는 js 파일의 경로가 잘못되어서였다. webpack output 설정에서 publickPath를 생각없이 복붙했다가 문제가 되었다.

구글링하면 환경변수로 react port 번호나 mode(publish, development) 등을 이용하는데, 환경변수를 사용한 내용을 보면 이런건 어떻게 배우거나 외우는건지 막막하다.

package.json의 한 스크립트에서 여러 명령어를 치려면 && 를 이용한다. 또 어떤 작업을 기다린 후 스크립트를 진행하려면 wait-on을 사용하면 된다.

electron에선 HashRouter 써야한다. url 변화 없이 파일기반 환경이기 때문에 해쉬값만 바꿔가며 보여줄 내용을 구분해야한다.

oracle vm에 라즈비안을 깐 뒤 빌드한 electron 설치파일을 테스트 해보려 했으나 가상환경 OS로 파일 옮기는 방식이 귀찮아서 보류했다.



### 2022/10/20/목

electron과 react간 ipc 통신을 확인했다. 모션인식에 사용되는 라즈베리파이에서 왭과 음성인식을 처리하는 라즈베리 파이로 데이터를 전송하면 electron이 react로 다시 ipc 통신을 하고, react에서 해당 데이터를 보여주거나 서버로 보내는 등의 데이터 처리를 진행한다. electron에서 주어지는 ipcMain과 ipcRenderer객체, webContents 메소드를 이용해 구현 가능하다.

webRTC 통신을 위해서 서버와의 소켓 API 형식을 맞췄다. API 문서에 작성했으며, 앱에서 서버로 실시간 트레이닝을 진행한다고 결정을 날리면 서버는 거울 기기에게 상대방 기기Id를 보내주게 된다. 그러면 기기는 해당 id를 URL일부로 사용하는 소켓을 통해 상대방 기기와 icebracking을 진행한다. 기기간 소켓통신의 경우 body의 type 속성에 2를 넣고 이땐 서버에서 처리없이 그냥 전송만 담당한다. 서버에서 기기로 통신을 시작하라고 기기Id를 전송할 땐 type을 1로 하여 여러 소켓경로를 사용하지 않아도 fe처리를 쉽게 하도록 했다.
